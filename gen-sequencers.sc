val dropUnits: String =
  """  given dropBothUnits: Sequencer[Unit, Unit, Unit] with {
    |    override def apply(l: Unit, r: Unit) = ()
    |  }
    |
    |  given dropLeftUnit[R : nu]: Sequencer[Unit, R, R] with {
    |    override def apply(l: Unit, r: R) = r
    |  }
    |
    |  given dropRightUnit[L : nu]: Sequencer[L, Unit, L] with {
    |    override def apply(l: L, r: Unit) = l
    |  }
    |""".stripMargin

def nthSequencer(n: Int): String =
  require(n > 2)
  val tNminus1 = (1 until n).map(i => s"T$i").mkString(",")
  s"""  given toTuple$n[$tNminus1, R : nu]: Sequencer[($tNminus1), R, ($tNminus1, R)] with {
     |    override def apply(l: ($tNminus1), r: R) = (${(1 until n).map(i => s"l._$i").mkString(",")}, r)
     |  }
     |""".stripMargin

def toTuple2(n: Int): String =
  require(n > 2)
  s"""  given toTuple2[L : nu : ${(2 until n).map(i => s"nt$i").mkString(":")}, R : nu]: Sequencer[L, R, (L, R)] with {
     |    override def apply(l: L, r: R) = (l, r)
     |  }
     |""".stripMargin

val not: String = "private type Not[x] = scala.util.NotGiven[x]"
val nt: String = "private type nu[x] = Not[x =:= Unit]"

def nts(n: Int): String =
  require(n > 1)
  "?".repeat(n)
  s"""private type nt$n[x] = Not[x <:< (${"?".repeat(n).mkString(",")})]"""

def generateSequencers(n: Int): String =
  require(n > 2)
  s"""// generated by gen-sequencers.sc, n = $n
     |// format: off
     |package dev.vgerasimov.slowparse
     |
     |object Sequencers {
     |
     |  // types
     |  $not
     |  $nt
     |  ${(2 to n).map(nts).mkString("\n  ")}
     |
     |  // givens
     |
     |$dropUnits
     |${toTuple2(n)}
     |${(3 to n).map(nthSequencer).mkString("\n")}
     |}
     |// format: on\n
     |""".stripMargin

println(generateSequencers(22))