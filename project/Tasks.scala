object Tasks {

  private val dropUnits: String =
    """  given dropBothUnits: Sequencer[Unit, Unit, Unit] with {
      |    override def apply(l: Unit, r: Unit) = ()
      |  }
      |
      |  given dropLeftUnit[R : nu]: Sequencer[Unit, R, R] with {
      |    override def apply(l: Unit, r: R) = r
      |  }
      |
      |  given dropRightUnit[L : nu]: Sequencer[L, Unit, L] with {
      |    override def apply(l: L, r: Unit) = l
      |  }
      |""".stripMargin

  private def nthSequencer(n: Int): String = {
    require(n > 2)
    val tNminus1 = (1 until n).map(i => s"T$i").mkString(",")
    s"""  given toTuple$n[$tNminus1, R : nu]: Sequencer[($tNminus1), R, ($tNminus1, R)] with {
       |    override def apply(l: ($tNminus1), r: R) = (${(1 until n).map(i => s"l._$i").mkString(",")}, r)
       |  }
       |""".stripMargin
  }

  private def toTuple2(n: Int): String = {
    require(n > 2)
    s"""  given toTuple2[L : nu : ${(2 until n).map(i => s"nt$i").mkString(":")}, R : nu]: Sequencer[L, R, (L, R)] with {
       |    override def apply(l: L, r: R) = (l, r)
       |  }
       |""".stripMargin
  }

  private val not: String = "private type Not[x] = scala.util.NotGiven[x]"
  private val nt: String = "private type nu[x] = Not[x =:= Unit]"

  private def nts(n: Int): String = {
    require(n > 1)
    s"""private type nt$n[x] = Not[x <:< (${"?".repeat(n).mkString(",")})]"""
  }

  def generateSequencers(n: Int): String = {
    require(n > 2)
    s"""// generated by gen-sequencers.sc, n = $n
       |// format: off
       |package dev.vgerasimov.slowparse
       |
       |object Sequencers {
       |
       |  // types
       |  $not
       |  $nt
       |  ${(2 to n).map(nts).mkString("\n  ")}
       |
       |  // givens
       |
       |$dropUnits
       |${toTuple2(n)}
       |${(3 to n).map(nthSequencer).mkString("\n")}
       |}
       |// format: on\n
       |""".stripMargin
  }
}
